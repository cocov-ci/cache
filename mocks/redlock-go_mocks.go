// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/heyvito/redlock-go (interfaces: Redlock)

// Package mocks is a generated GoMock package.
package mocks

import (
	reflect "reflect"

	redlock "github.com/heyvito/redlock-go"
	gomock "go.uber.org/mock/gomock"
)

// MockRedlock is a mock of Redlock interface.
type MockRedlock struct {
	ctrl     *gomock.Controller
	recorder *MockRedlockMockRecorder
}

// MockRedlockMockRecorder is the mock recorder for MockRedlock.
type MockRedlockMockRecorder struct {
	mock *MockRedlock
}

// NewMockRedlock creates a new mock instance.
func NewMockRedlock(ctrl *gomock.Controller) *MockRedlock {
	mock := &MockRedlock{ctrl: ctrl}
	mock.recorder = &MockRedlockMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRedlock) EXPECT() *MockRedlockMockRecorder {
	return m.recorder
}

// ExtendLock mocks base method.
func (m *MockRedlock) ExtendLock(arg0 *redlock.LockInfo, arg1 int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExtendLock", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// ExtendLock indicates an expected call of ExtendLock.
func (mr *MockRedlockMockRecorder) ExtendLock(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExtendLock", reflect.TypeOf((*MockRedlock)(nil).ExtendLock), arg0, arg1)
}

// IsLockValid mocks base method.
func (m *MockRedlock) IsLockValid(arg0 *redlock.LockInfo) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsLockValid", arg0)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsLockValid indicates an expected call of IsLockValid.
func (mr *MockRedlockMockRecorder) IsLockValid(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsLockValid", reflect.TypeOf((*MockRedlock)(nil).IsLockValid), arg0)
}

// IsLocked mocks base method.
func (m *MockRedlock) IsLocked(arg0 string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsLocked", arg0)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsLocked indicates an expected call of IsLocked.
func (mr *MockRedlockMockRecorder) IsLocked(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsLocked", reflect.TypeOf((*MockRedlock)(nil).IsLocked), arg0)
}

// Lock mocks base method.
func (m *MockRedlock) Lock(arg0 string, arg1 int) (*redlock.LockInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Lock", arg0, arg1)
	ret0, _ := ret[0].(*redlock.LockInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Lock indicates an expected call of Lock.
func (mr *MockRedlockMockRecorder) Lock(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Lock", reflect.TypeOf((*MockRedlock)(nil).Lock), arg0, arg1)
}

// Locking mocks base method.
func (m *MockRedlock) Locking(arg0 string, arg1 int, arg2 func() error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Locking", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// Locking indicates an expected call of Locking.
func (mr *MockRedlockMockRecorder) Locking(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Locking", reflect.TypeOf((*MockRedlock)(nil).Locking), arg0, arg1, arg2)
}

// RemainingTTLForLock mocks base method.
func (m *MockRedlock) RemainingTTLForLock(arg0 *redlock.LockInfo) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemainingTTLForLock", arg0)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RemainingTTLForLock indicates an expected call of RemainingTTLForLock.
func (mr *MockRedlockMockRecorder) RemainingTTLForLock(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemainingTTLForLock", reflect.TypeOf((*MockRedlock)(nil).RemainingTTLForLock), arg0)
}

// RemainingTTLForResource mocks base method.
func (m *MockRedlock) RemainingTTLForResource(arg0 string) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemainingTTLForResource", arg0)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RemainingTTLForResource indicates an expected call of RemainingTTLForResource.
func (mr *MockRedlockMockRecorder) RemainingTTLForResource(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemainingTTLForResource", reflect.TypeOf((*MockRedlock)(nil).RemainingTTLForResource), arg0)
}

// TryGetRemainingTTL mocks base method.
func (m *MockRedlock) TryGetRemainingTTL(arg0 string) (bool, string, int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TryGetRemainingTTL", arg0)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(int)
	ret3, _ := ret[3].(error)
	return ret0, ret1, ret2, ret3
}

// TryGetRemainingTTL indicates an expected call of TryGetRemainingTTL.
func (mr *MockRedlockMockRecorder) TryGetRemainingTTL(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TryGetRemainingTTL", reflect.TypeOf((*MockRedlock)(nil).TryGetRemainingTTL), arg0)
}

// Unlock mocks base method.
func (m *MockRedlock) Unlock(arg0 *redlock.LockInfo) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Unlock", arg0)
}

// Unlock indicates an expected call of Unlock.
func (mr *MockRedlockMockRecorder) Unlock(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unlock", reflect.TypeOf((*MockRedlock)(nil).Unlock), arg0)
}
